The dependency graph centers on `src/run.py`, which initializes the Flask app and registers the Module 1 and Module 3 blueprints. `M3_material.board.pages` handles the dashboard routes and depends on `M3_material.query_data` for analytics and `M3_material.reporting` for PDF generation. The query layer uses `psycopg` and `db.db_config` to connect to PostgreSQL using parameterized SQL. The ETL pipeline (`M2_material.pull_data`, `M2_material.scrape`, and `M2_material.clean`) fetches GradCafe pages with `urllib3`, parses them with `BeautifulSoup`, and normalizes fields before insertion. LLM normalization lives in `llm_hosting.app`, which uses `huggingface_hub` and `llama_cpp` to load and run the local model for program/university cleanup. Shared normalization helpers in `db.normalize` are reused by both the pull and import flows to keep the schema consistent.
